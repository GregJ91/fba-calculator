<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBA Calculator - Extreme Stress Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .header {
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .test-category {
            margin: 30px 0;
            padding: 25px;
            background: rgba(255,255,255,0.95);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        .test-case {
            margin: 12px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 6px solid #ddd;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        .test-case:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .pass {
            background-color: #e8f5e8;
            border-left-color: #4caf50;
        }
        .fail {
            background-color: #ffeaea;
            border-left-color: #f44336;
        }
        .warning {
            background-color: #fff8e1;
            border-left-color: #ff9800;
        }
        .error {
            background-color: #ffebee;
            border-left-color: #e91e63;
        }
        .critical {
            background-color: #f3e5f5;
            border-left-color: #9c27b0;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        .summary {
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        .test-details {
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
        }
        .progress {
            background-color: rgba(255,255,255,0.3);
            border-radius: 20px;
            height: 25px;
            margin: 15px 0;
            overflow: hidden;
        }
        .progress-bar {
            background: linear-gradient(90deg, #4caf50, #45a049);
            height: 100%;
            border-radius: 20px;
            transition: width 0.5s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            margin: 25px 0;
            text-align: center;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 8px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .severity-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .severity-low { background-color: #4caf50; }
        .severity-medium { background-color: #ff9800; }
        .severity-high { background-color: #f44336; }
        .severity-critical { background-color: #9c27b0; }
    </style>
    <script src="fba-calculator.js?v=20250812-extreme"></script>
</head>
<body>
    <div class="header">
        <h1>üî• FBA Calculator - EXTREME Stress Test</h1>
        <p>Pushing the calculator to absolute limits with extreme edge cases, boundary conditions, and stress scenarios</p>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="totalTestsCount">0</div>
                <div>Total Tests</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="passRatePercent">0%</div>
                <div>Pass Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="criticalFailures">0</div>
                <div>Critical Issues</div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="runExtremeTest" class="btn">üöÄ Run EXTREME Stress Test</button>
        <button id="runCriticalOnly" class="btn">‚ö° Critical Edge Cases Only</button>
        <button id="runPerformanceTest" class="btn">üèÉ Performance Torture Test</button>
        <button id="stopTest" class="btn" disabled>üõë Stop Test</button>
    </div>

    <div id="progress" class="progress" style="display: none;">
        <div id="progressBar" class="progress-bar" style="width: 0%"></div>
    </div>
    <div id="progressText" style="text-align: center; margin: 15px 0; display: none; color: white; font-weight: bold;"></div>

    <div id="summary" class="summary">
        <h2>Extreme Stress Test Results</h2>
        <div id="summaryContent">Select a test mode to begin extreme validation...</div>
    </div>
    
    <div id="testResults"></div>
    
    <script>
        class ExtremeStressTest {
            constructor() {
                this.calculator = new FBACalculator();
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.errorTests = 0;
                this.warningTests = 0;
                this.criticalTests = 0;
                this.testResults = [];
                this.isRunning = false;
                this.shouldStop = false;
                this.startTime = null;
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('runExtremeTest').addEventListener('click', () => this.runExtremeStressTest());
                document.getElementById('runCriticalOnly').addEventListener('click', () => this.runCriticalEdgeCases());
                document.getElementById('runPerformanceTest').addEventListener('click', () => this.runPerformanceTortureTest());
                document.getElementById('stopTest').addEventListener('click', () => this.stopTest());
            }

            updateProgress(current, total, category = '') {
                const percentage = (current / total) * 100;
                document.getElementById('progressBar').style.width = `${percentage}%`;
                document.getElementById('progressText').textContent = 
                    `${category} - Test ${current}/${total} (${percentage.toFixed(1)}%)`;
                
                // Update live stats
                document.getElementById('totalTestsCount').textContent = this.totalTests;
                const passRate = this.totalTests > 0 ? ((this.passedTests / this.totalTests) * 100).toFixed(1) : '0.0';
                document.getElementById('passRatePercent').textContent = `${passRate}%`;
                document.getElementById('criticalFailures').textContent = this.criticalTests;
            }

            showProgress() {
                document.getElementById('progress').style.display = 'block';
                document.getElementById('progressText').style.display = 'block';
                document.getElementById('runExtremeTest').disabled = true;
                document.getElementById('runCriticalOnly').disabled = true;
                document.getElementById('runPerformanceTest').disabled = true;
                document.getElementById('stopTest').disabled = false;
                this.isRunning = true;
                this.shouldStop = false;
                this.startTime = Date.now();
            }

            hideProgress() {
                document.getElementById('progress').style.display = 'none';
                document.getElementById('progressText').style.display = 'none';
                document.getElementById('runExtremeTest').disabled = false;
                document.getElementById('runCriticalOnly').disabled = false;
                document.getElementById('runPerformanceTest').disabled = false;
                document.getElementById('stopTest').disabled = true;
                this.isRunning = false;
            }

            stopTest() {
                this.shouldStop = true;
                this.hideProgress();
            }

            async runExtremeStressTest() {
                this.resetResults();
                this.showProgress();
                
                try {
                    // Category 1: Microscopic Edge Cases
                    await this.testMicroscopicEdgeCases();
                    if (this.shouldStop) return;

                    // Category 2: Gigantic Extremes
                    await this.testGiganticExtremes();
                    if (this.shouldStop) return;

                    // Category 3: Floating Point Nightmares
                    await this.testFloatingPointNightmares();
                    if (this.shouldStop) return;

                    // Category 4: Boundary Precision Hell
                    await this.testBoundaryPrecisionHell();
                    if (this.shouldStop) return;

                    // Category 5: Weight vs Dimensional Weight Wars
                    await this.testWeightDimensionalWars();
                    if (this.shouldStop) return;

                    // Category 6: Zone Coverage Extremes
                    await this.testZoneCoverageExtremes();
                    if (this.shouldStop) return;

                    // Category 7: Surcharge Calculation Torture
                    await this.testSurchargeCalculationTorture();
                    if (this.shouldStop) return;

                    // Category 8: Real World Nightmare Scenarios
                    await this.testRealWorldNightmares();
                    if (this.shouldStop) return;

                    // Category 9: Performance Breaking Points
                    await this.testPerformanceBreakingPoints();
                    if (this.shouldStop) return;

                    // Category 10: Invalid Input Chaos
                    await this.testInvalidInputChaos();
                    if (this.shouldStop) return;

                } catch (error) {
                    this.addCriticalResult('EXTREME TEST SYSTEM FAILURE', error.message, {}, 0);
                } finally {
                    this.hideProgress();
                    this.displayResults();
                    this.displaySummary();
                }
            }

            async runCriticalEdgeCases() {
                this.resetResults();
                this.showProgress();
                
                try {
                    await this.testBoundaryPrecisionHell();
                    if (this.shouldStop) return;
                    
                    await this.testWeightDimensionalWars();
                    if (this.shouldStop) return;
                    
                    await this.testFloatingPointNightmares();
                    if (this.shouldStop) return;
                    
                } catch (error) {
                    this.addCriticalResult('CRITICAL TEST SYSTEM FAILURE', error.message, {}, 0);
                } finally {
                    this.hideProgress();
                    this.displayResults();
                    this.displaySummary();
                }
            }

            async runPerformanceTortureTest() {
                this.resetResults();
                this.showProgress();
                
                try {
                    await this.testPerformanceBreakingPoints(true); // Extreme mode
                    
                } catch (error) {
                    this.addCriticalResult('PERFORMANCE TORTURE FAILURE', error.message, {}, 0);
                } finally {
                    this.hideProgress();
                    this.displayResults();
                    this.displaySummary();
                }
            }

            resetResults() {
                this.totalTests = 0;
                this.passedTests = 0;
                this.failedTests = 0;
                this.errorTests = 0;
                this.warningTests = 0;
                this.criticalTests = 0;
                this.testResults = [];
            }

            // EXTREME TEST CATEGORIES

            async testMicroscopicEdgeCases() {
                const category = "üî¨ Microscopic Edge Cases";
                const tests = [
                    { name: "Atom-sized item", dims: [0.001, 0.001, 0.001], weight: 0.000001, expected: "Small envelope", severity: "high" },
                    { name: "Planck length dimensions", dims: [0.0000000000000001, 0.0000000000000001, 0.0000000000000001], weight: 0.000001, expected: null, severity: "critical" },
                    { name: "Zero volume item", dims: [10, 10, 0], weight: 1, expected: null, severity: "critical" },
                    { name: "Negative zero weight", dims: [10, 10, 10], weight: -0.0, expected: "Small envelope", severity: "medium" },
                    { name: "Minimum float precision", dims: [Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE], weight: Number.MIN_VALUE, expected: null, severity: "critical" },
                    { name: "Microscopic weight precision", dims: [10, 10, 10], weight: 0.0000000001, expected: "Small envelope", severity: "low" },
                    { name: "Quantum-scale dimensions", dims: [0.00000000000001, 0.00000000000001, 0.00000000000001], weight: 0.001, expected: null, severity: "critical" },
                ];
                await this.runCategoryTests(category, tests, true);
            }

            async testGiganticExtremes() {
                const category = "üèóÔ∏è Gigantic Extremes";
                const tests = [
                    { name: "Building-sized item", dims: [10000, 5000, 3000], weight: 100000, expected: "Special oversize", severity: "high" },
                    { name: "Maximum safe integer", dims: [Number.MAX_SAFE_INTEGER, 100, 100], weight: 1000, expected: "Special oversize", severity: "critical" },
                    { name: "Astronomical weight", dims: [100, 100, 100], weight: 999999999, expected: "Special oversize", severity: "high" },
                    { name: "Near-infinite dimensions", dims: [Number.MAX_VALUE/1000000, 100, 100], weight: 1000, expected: "Special oversize", severity: "critical" },
                    { name: "Skyscraper height", dims: [500, 500, 50000], weight: 50000, expected: "Special oversize", severity: "medium" },
                    { name: "Container ship size", dims: [40000, 5900, 2600], weight: 200000, expected: "Special oversize", severity: "medium" },
                    { name: "Blue whale dimensions", dims: [3000, 400, 400], weight: 200000, expected: "Special oversize", severity: "low" },
                ];
                await this.runCategoryTests(category, tests);
            }

            async testFloatingPointNightmares() {
                const category = "üëπ Floating Point Nightmares";
                const tests = [
                    { name: "0.1 + 0.2 classic", dims: [10, 10, 10], weight: 0.1 + 0.2, expected: "Small envelope", severity: "high" },
                    { name: "Precision loss cascade", dims: [10.000000000000002, 10.000000000000002, 10.000000000000002], weight: 1.0000000000000002, expected: "Standard parcel", severity: "critical" },
                    { name: "Epsilon boundary", dims: [20 + Number.EPSILON, 15, 1], weight: 0.08, expected: "Standard envelope", severity: "critical" },
                    { name: "Near-zero difference", dims: [35.00000000000001, 25, 2.5], weight: 0.46, expected: "Standard envelope", severity: "high" },
                    { name: "Rounding error accumulation", dims: [19.999999999999996, 14.999999999999998, 0.9999999999999999], weight: 0.079999999999999999, expected: "Small envelope", severity: "critical" },
                    { name: "Subnormal numbers", dims: [10, 10, 10], weight: 5e-324, expected: "Small envelope", severity: "critical" },
                    { name: "Float precision limits", dims: [35 - 1e-15, 25 - 1e-15, 2.5 - 1e-15], weight: 0.46 - 1e-15, expected: "Standard envelope", severity: "high" },
                ];
                await this.runCategoryTests(category, tests, true);
            }

            async testBoundaryPrecisionHell() {
                const category = "üéØ Boundary Precision Hell";
                const tests = [
                    { name: "20.0000000000001cm boundary", dims: [20.0000000000001, 15, 1], weight: 0.08, expected: "Standard envelope", severity: "critical" },
                    { name: "Exactly 31.5000000000000kg", dims: [130, 50, 50], weight: 31.5000000000000, expected: "Special oversize", severity: "critical" },
                    { name: "31.49999999999999kg", dims: [130, 50, 50], weight: 31.49999999999999, expected: "Large oversize", severity: "critical" },
                    { name: "175.00000000000001cm length", dims: [175.00000000000001, 50, 50], weight: 20, expected: "Special oversize", severity: "critical" },
                    { name: "Girth exactly 360.000000cm", dims: [120, 80, 80], weight: 20, expected: "Large oversize", severity: "critical" },
                    { name: "Girth 360.000000000001cm", dims: [120.000000000001, 80, 80], weight: 20, expected: "Special oversize", severity: "critical" },
                    { name: "Dimensional weight 68.39999999kg", dims: [119.9, 59.9, 59.9], weight: 10, expected: "Standard oversize", severity: "critical" },
                    { name: "Dimensional weight 68.40000001kg", dims: [120.1, 60, 60], weight: 10, expected: "Large oversize", severity: "critical" },
                ];
                await this.runCategoryTests(category, tests);
            }

            async testWeightDimensionalWars() {
                const category = "‚öîÔ∏è Weight vs Dimensional Weight Wars";
                const tests = [
                    { name: "Extreme lightweight balloon", dims: [200, 200, 200], weight: 0.001, expected: "Special oversize", severity: "high" },
                    { name: "Ultra-dense neutron star material", dims: [1, 1, 1], weight: 1000000, expected: "Special oversize", severity: "high" },
                    { name: "Aerogel paradox", dims: [100, 100, 100], weight: 0.01, expected: "Special oversize", severity: "medium" },
                    { name: "Lead brick vs balloon", dims: [10, 10, 10], weight: 50, expected: "Special oversize", severity: "medium" },
                    { name: "Dimensional weight exactly equals unit", dims: [35.36, 35.36, 35.36], weight: 8.84, expected: "Standard oversize", severity: "high" },
                    { name: "Microscopic difference favor dim", dims: [35.36, 35.36, 35.36], weight: 8.839999, expected: "Standard oversize", severity: "critical" },
                    { name: "Microscopic difference favor unit", dims: [35.36, 35.36, 35.36], weight: 8.840001, expected: "Standard oversize", severity: "critical" },
                    { name: "Oversize pricing weight test", dims: [45, 35, 15], weight: 5, expected: "Standard oversize", severity: "high", expectedPricingWeight: 4.725 },
                ];
                await this.runCategoryTests(category, tests);
            }

            async testZoneCoverageExtremes() {
                const category = "üåç Zone Coverage Extremes";
                const baseTest = { dims: [200, 50, 50], weight: 25, expected: "Special oversize" };
                const tests = [
                    { ...baseTest, name: "UK null service stress", zone: "UK", severity: "low" },
                    { ...baseTest, name: "DE extreme oversize", zone: "DE", severity: "medium" },
                    { ...baseTest, name: "SE null service boundary", zone: "SE", severity: "high" },
                    { ...baseTest, name: "NL service unavailable", zone: "NL", severity: "high" },
                    { ...baseTest, name: "PL null service edge", zone: "PL", severity: "high" },
                    { name: "Invalid zone code", dims: [10, 10, 10], weight: 1, zone: "INVALID", expected: null, severity: "critical" },
                    { name: "Empty zone string", dims: [10, 10, 10], weight: 1, zone: "", expected: null, severity: "critical" },
                    { name: "Null zone", dims: [10, 10, 10], weight: 1, zone: null, expected: null, severity: "critical" },
                ];
                await this.runCategoryTests(category, tests, true);
            }

            async testSurchargeCalculationTorture() {
                const category = "üí∞ Surcharge Calculation Torture";
                const tests = [
                    { name: "Small oversize 1.760000000001kg", dims: [50, 40, 30], weight: 1.760000000001, expected: "Small oversize", severity: "critical" },
                    { name: "Standard oversize 29.760000000001kg", dims: [100, 50, 50], weight: 29.760000000001, expected: "Standard oversize", severity: "critical" },
                    { name: "Large oversize 31.500000000001kg", dims: [130, 50, 50], weight: 31.500000000001, expected: "Special oversize", severity: "critical" },
                    { name: "Special oversize 60.000000000001kg", dims: [200, 50, 50], weight: 60.000000000001, expected: "Special oversize", severity: "high" },
                    { name: "Microscopic surcharge amount", dims: [50, 40, 30], weight: 1.76 + 1e-10, expected: "Small oversize", severity: "critical" },
                    { name: "Maximum surcharge weight", dims: [50, 40, 30], weight: 4.76, expected: "Small oversize", severity: "medium" },
                    { name: "Surcharge precision rounding", dims: [100, 50, 50], weight: 32.768, expected: "Standard oversize", severity: "high" },
                ];
                await this.runCategoryTests(category, tests);
            }

            async testRealWorldNightmares() {
                const category = "üå™Ô∏è Real World Nightmares";
                const tests = [
                    { name: "Inflatable swimming pool", dims: [366, 366, 76], weight: 15, expected: "Special oversize", severity: "medium" },
                    { name: "Disassembled furniture", dims: [200, 40, 8], weight: 45, expected: "Special oversize", severity: "medium" },
                    { name: "Rolled carpet", dims: [500, 30, 30], weight: 25, expected: "Special oversize", severity: "medium" },
                    { name: "Telescope tube", dims: [180, 25, 25], weight: 8, expected: "Special oversize", severity: "medium" },
                    { name: "Yoga mat bundle", dims: [185, 60, 60], weight: 12, expected: "Special oversize", severity: "medium" },
                    { name: "Awkward L-shaped item", dims: [120, 100, 20], weight: 15, expected: "Special oversize", severity: "high" },
                    { name: "Extremely thin metal sheet", dims: [200, 100, 0.1], weight: 50, expected: "Special oversize", severity: "high" },
                    { name: "Hollow aluminum tube", dims: [300, 15, 15], weight: 2, expected: "Special oversize", severity: "medium" },
                    { name: "Compressed foam mattress", dims: [200, 150, 5], weight: 20, expected: "Special oversize", severity: "medium" },
                    { name: "Collapsible tent", dims: [60, 20, 20], weight: 8, expected: "Standard oversize", severity: "low" },
                ];
                await this.runCategoryTests(category, tests);
            }

            async testPerformanceBreakingPoints(extremeMode = false) {
                const category = "üèÉ Performance Breaking Points";
                const tests = [];
                
                const iterations = extremeMode ? 1000 : 200;
                
                // Generate stress test scenarios
                for (let i = 0; i < iterations; i++) {
                    const scenario = this.generateRandomExtremeScenario(i);
                    tests.push({
                        name: `Performance stress ${i + 1}`,
                        dims: scenario.dims,
                        weight: scenario.weight,
                        zone: scenario.zone,
                        expected: null, // Accept any result
                        severity: "low",
                        isPerformanceTest: true
                    });
                }

                await this.runCategoryTests(category, tests);
            }

            async testInvalidInputChaos() {
                const category = "üí• Invalid Input Chaos";
                const tests = [
                    { name: "NaN dimensions", dims: [NaN, NaN, NaN], weight: 1, expected: null, severity: "critical" },
                    { name: "Infinity weight", dims: [10, 10, 10], weight: Infinity, expected: null, severity: "critical" },
                    { name: "Negative infinity dimensions", dims: [-Infinity, 10, 10], weight: 1, expected: null, severity: "critical" },
                    { name: "String dimensions", dims: ["10", "10", "10"], weight: 1, expected: null, severity: "critical" },
                    { name: "Undefined weight", dims: [10, 10, 10], weight: undefined, expected: null, severity: "critical" },
                    { name: "Array as dimension", dims: [[10], 10, 10], weight: 1, expected: null, severity: "critical" },
                    { name: "Object as weight", dims: [10, 10, 10], weight: {value: 1}, expected: null, severity: "critical" },
                    { name: "Boolean dimensions", dims: [true, false, true], weight: 1, expected: null, severity: "critical" },
                ];
                await this.runCategoryTests(category, tests, true);
            }

            generateRandomExtremeScenario(seed) {
                // Seeded random for reproducible results
                const random = () => {
                    const x = Math.sin(seed++) * 10000;
                    return x - Math.floor(x);
                };

                const scenarios = [
                    // Extreme lightweight
                    { dims: [random() * 200 + 50, random() * 200 + 50, random() * 200 + 50], weight: random() * 0.1 + 0.001 },
                    // Extreme heavyweight
                    { dims: [random() * 50 + 10, random() * 50 + 10, random() * 50 + 10], weight: random() * 100 + 20 },
                    // Extreme dimensions
                    { dims: [random() * 500 + 100, random() * 100 + 20, random() * 100 + 20], weight: random() * 50 + 5 },
                    // Boundary cases
                    { dims: [20 + (random() - 0.5) * 0.1, 15 + (random() - 0.5) * 0.1, 1 + (random() - 0.5) * 0.01], weight: 0.21 + (random() - 0.5) * 0.001 },
                ];

                const scenario = scenarios[Math.floor(random() * scenarios.length)];
                const zones = ['UK', 'DE', 'FR', 'IT', 'ES', 'NL', 'SE', 'PL', 'BE'];
                scenario.zone = zones[Math.floor(random() * zones.length)];
                
                return scenario;
            }

            async runCategoryTests(categoryName, tests, allowErrors = false) {
                if (this.shouldStop) return;

                const categoryResults = {
                    name: categoryName,
                    tests: [],
                    passed: 0,
                    failed: 0,
                    errors: 0,
                    warnings: 0,
                    critical: 0,
                    total: tests.length
                };

                for (let i = 0; i < tests.length; i++) {
                    if (this.shouldStop) break;
                    
                    this.updateProgress(i + 1, tests.length, categoryName);
                    
                    const test = tests[i];
                    const result = await this.runSingleTest(test, allowErrors);
                    categoryResults.tests.push(result);
                    
                    if (result.status === 'pass') categoryResults.passed++;
                    else if (result.status === 'fail') categoryResults.failed++;
                    else if (result.status === 'error') categoryResults.errors++;
                    else if (result.status === 'warning') categoryResults.warnings++;
                    else if (result.status === 'critical') categoryResults.critical++;
                    
                    // Micro delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 0.1));
                }

                this.testResults.push(categoryResults);
            }

            async runSingleTest(test, allowErrors = false) {
                this.totalTests++;
                
                try {
                    const { dims, weight, expected, zone = 'UK', severity = 'low', isPerformanceTest = false, expectedPricingWeight } = test;
                    
                    // Validate inputs first
                    if (this.hasInvalidInputs(dims, weight)) {
                        if (allowErrors || severity === 'critical') {
                            this.criticalTests++;
                            return {
                                ...test,
                                actualTier: 'Invalid Input',
                                actualFee: 'N/A',
                                status: 'critical',
                                message: 'Invalid input detected (expected for extreme test)',
                                severity: severity
                            };
                        } else {
                            this.errorTests++;
                            return {
                                ...test,
                                actualTier: 'Error',
                                actualFee: 'N/A',
                                status: 'error',
                                message: 'Invalid input',
                                severity: severity
                            };
                        }
                    }

                    const dimensions = { height: dims[0], width: dims[1], depth: dims[2] };
                    const sortedDims = dims.sort((a, b) => b - a);
                    const dimensionalWeight = this.calculator.calculateDimensionalWeight(sortedDims[0], sortedDims[1], sortedDims[2]);
                    
                    const tier = this.calculator.determineSizeTier(dimensions, weight, dimensionalWeight);
                    const weightBracket = this.calculator.findWeightBracket(tier, weight);
                    const fee = this.calculator.calculateFee(tier, weight, zone, weightBracket);
                    
                    let status = 'pass';
                    let message = '';
                    
                    if (isPerformanceTest) {
                        status = 'pass';
                        message = 'Performance test completed';
                        this.passedTests++;
                    } else if (expected && tier.name !== expected) {
                        if (severity === 'critical') {
                            status = 'critical';
                            this.criticalTests++;
                        } else {
                            status = 'fail';
                            this.failedTests++;
                        }
                        message = `Expected ${expected}, got ${tier.name}`;
                    } else if (!expected) {
                        status = 'pass';
                        message = 'Stability test passed';
                        this.passedTests++;
                    } else {
                        this.passedTests++;
                    }

                    // Check pricing weight if specified
                    if (expectedPricingWeight) {
                        const actualPricingWeight = tier.name.includes('oversize') && dimensionalWeight < weight ? dimensionalWeight : Math.max(weight, dimensionalWeight);
                        if (Math.abs(actualPricingWeight - expectedPricingWeight) > 0.001) {
                            status = 'fail';
                            message += ` | Pricing weight: expected ${expectedPricingWeight}kg, got ${actualPricingWeight.toFixed(3)}kg`;
                            if (status === 'pass') this.passedTests--;
                            this.failedTests++;
                        }
                    }
                    
                    return {
                        ...test,
                        actualTier: tier.name,
                        actualFee: fee,
                        dimensionalWeight: dimensionalWeight.toFixed(6),
                        weightBracket: weightBracket.description,
                        status: status,
                        message: message,
                        severity: severity
                    };
                    
                } catch (error) {
                    if (test.severity === 'critical') {
                        this.criticalTests++;
                        return {
                            ...test,
                            actualTier: 'Critical Error',
                            actualFee: 'N/A',
                            status: 'critical',
                            message: `Critical system error: ${error.message}`,
                            severity: test.severity || 'critical'
                        };
                    } else {
                        this.errorTests++;
                        return {
                            ...test,
                            actualTier: 'Error',
                            actualFee: 'N/A',
                            status: 'error',
                            message: error.message,
                            severity: test.severity || 'high'
                        };
                    }
                }
            }

            hasInvalidInputs(dims, weight) {
                return dims.some(d => d <= 0 || !isFinite(d) || isNaN(d) || typeof d !== 'number') ||
                       weight < 0 || !isFinite(weight) || isNaN(weight) || typeof weight !== 'number';
            }

            addCriticalResult(name, message, dims, weight) {
                this.totalTests++;
                this.criticalTests++;
                this.testResults.push({
                    name: 'üö® CRITICAL SYSTEM FAILURES',
                    tests: [{
                        name: name,
                        dims: dims,
                        weight: weight,
                        actualTier: 'SYSTEM FAILURE',
                        actualFee: 'N/A',
                        status: 'critical',
                        message: message,
                        severity: 'critical'
                    }],
                    passed: 0,
                    failed: 0,
                    errors: 0,
                    warnings: 0,
                    critical: 1,
                    total: 1
                });
            }

            displayResults() {
                const resultsContainer = document.getElementById('testResults');
                let html = '';

                this.testResults.forEach(category => {
                    const passRate = category.total > 0 ? ((category.passed / category.total) * 100).toFixed(1) : '0.0';
                    html += `
                        <div class="test-category">
                            <h2>${category.name}</h2>
                            <p><strong>Results:</strong> ${category.passed} passed, ${category.failed} failed, ${category.errors} errors, ${category.warnings} warnings, ${category.critical} critical (${passRate}% pass rate)</p>
                    `;

                    category.tests.forEach(test => {
                        const cssClass = test.status;
                        const statusIcon = {
                            'pass': '‚úÖ',
                            'fail': '‚ùå', 
                            'error': 'üö®',
                            'warning': '‚ö†Ô∏è',
                            'critical': 'üí•'
                        }[test.status] || '‚ùì';
                        
                        const severityClass = `severity-${test.severity || 'low'}`;
                        
                        html += `
                            <div class="test-case ${cssClass}">
                                <strong>${statusIcon} <span class="severity-indicator ${severityClass}"></span>${test.name}</strong>
                                ${test.message ? `<div style="color: #666; font-style: italic; margin-top: 5px;">${test.message}</div>` : ''}
                                <div class="test-details">
                                    <strong>Dimensions:</strong> ${test.dims ? test.dims.map(d => typeof d === 'number' ? d.toFixed(6) : d).join(' √ó ') : 'N/A'} cm |
                                    <strong>Weight:</strong> ${typeof test.weight === 'number' ? test.weight.toFixed(6) : test.weight || 'N/A'} kg |
                                    <strong>Expected:</strong> ${test.expected || 'N/A'} |
                                    <strong>Actual:</strong> ${test.actualTier || 'N/A'}
                                    ${test.dimensionalWeight ? ` | <strong>Dim Weight:</strong> ${test.dimensionalWeight} kg` : ''}
                                    ${test.actualFee && test.actualFee !== 'N/A' ? ` | <strong>Fee:</strong> ${test.actualFee}` : ''}
                                    ${test.zone && test.zone !== 'UK' ? ` | <strong>Zone:</strong> ${test.zone}` : ''}
                                    ${test.severity ? ` | <strong>Severity:</strong> ${test.severity.toUpperCase()}` : ''}
                                </div>
                            </div>
                        `;
                    });

                    html += '</div>';
                });

                resultsContainer.innerHTML = html;
            }

            displaySummary() {
                const passRate = this.totalTests > 0 ? ((this.passedTests / this.totalTests) * 100).toFixed(1) : '0.0';
                const duration = this.startTime ? ((Date.now() - this.startTime) / 1000).toFixed(2) : '0';
                
                let status = 'üéâ EXTREME TESTS PASSED';
                if (this.criticalTests > 0) status = 'üí• CRITICAL FAILURES DETECTED';
                else if (this.errorTests > 0) status = 'üö® SYSTEM ERRORS FOUND';
                else if (this.failedTests > 0) status = '‚ö†Ô∏è SOME EXTREME TESTS FAILED';
                
                document.getElementById('summaryContent').innerHTML = `
                    <h3>${status}</h3>
                    <p><strong>Execution Time:</strong> ${duration}s</p>
                    <p><strong>Total Tests:</strong> ${this.totalTests}</p>
                    <p><strong>Results:</strong> ${this.passedTests} passed, ${this.failedTests} failed, ${this.errorTests} errors, ${this.warningTests} warnings, ${this.criticalTests} critical</p>
                    <p><strong>Pass Rate:</strong> ${passRate}%</p>
                    <p><strong>Categories Tested:</strong> ${this.testResults.length}</p>
                    <p><strong>Extreme Coverage:</strong> Microscopic edge cases, gigantic extremes, floating point nightmares, boundary precision hell, weight wars, zone extremes, surcharge torture, real-world nightmares, performance breaking points, invalid input chaos</p>
                    <p><strong>System Status:</strong> ${this.criticalTests === 0 ? 'Calculator survived extreme torture testing! üöÄ' : `${this.criticalTests} critical issues require immediate attention! ‚ö°`}</p>
                `;
            }
        }

        // Initialize the extreme stress test when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ExtremeStressTest();
        });
    </script>
</body>
</html>
